fn expression_borked(&mut self) -> Result<Expr<'p>, ParseError> {
    let Token { lexeme, kind, line } = self.consume_or(ParseError::ExpectedExpression)?;

    let expr = match kind {
        TokenType::Empty => Expr::Literal(Value::Empty),
        TokenType::True => Expr::Literal(Value::Boolean(true)),
        TokenType::False => Expr::Literal(Value::Boolean(false)),
        TokenType::Number => {
            let num: f64 = lexeme.parse()?;
            Expr::Literal(Value::Number(num))
        }
        TokenType::String => Expr::Literal(Value::from(lexeme)),

        TokenType::Bang => Expr::UnOp {
            expr: Box::new(self.expression()?),
            op: Unary::Not,
        },
        TokenType::Plus => Expr::BinOp {
            left: Box::new(self.expression()?),
            right: Box::new(self.expression()?),
            op: Binary::Add,
        },
        TokenType::Minus => Expr::BinOp {
            left: Box::new(self.expression()?),
            right: Box::new(self.expression()?),
            op: Binary::Subtract,
        },
        TokenType::Asterisk => Expr::BinOp {
            right: Box::new(self.expression()?),
            left: Box::new(self.expression()?),
            op: Binary::Multiply,
        },
        TokenType::Slash => Expr::BinOp {
            right: Box::new(self.expression()?),
            left: Box::new(self.expression()?),
            op: Binary::Divide,
        },
        TokenType::Percent => Expr::BinOp {
            right: Box::new(self.expression()?),
            left: Box::new(self.expression()?),
            op: Binary::Modulo,
        },

        TokenType::Identifier => Expr::Variable { name: lexeme },

        TokenType::Equal => todo!(),

        kind => Err(ParseError::UnexpectedToken(kind))?,
    };

    Ok(expr)
}
