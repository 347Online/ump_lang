use crate::{
    error::ParseError,
    repr::{
        ast::{expr::Expr, stmt::Stmt},
        token::{Token, TokenType},
        value::Value,
    },
};

pub type Ast<'a> = Vec<Stmt<'a>>;

pub struct Parser<'p> {
    tokens: Vec<Token<'p>>,
    current: usize,
}

impl<'p> Parser<'p> {
    pub fn new(mut tokens: Vec<Token<'p>>) -> Self {
        tokens.reverse();
        Parser { tokens, current: 0 }
    }

    pub fn parse<'a>(mut self) -> Ast<'a> {
        let mut statements = vec![];
        while self.peek() != TokenType::Eof {
            let stmt = self.statement().unwrap();
            statements.push(stmt);
        }

        statements
    }

    fn statement(&mut self) -> Result<Stmt<'p>, ParseError> {
        let stmt = if self.peek() == TokenType::Print {
            let expr = self.expression()?;
            Stmt::Print(expr)
        } else {
            let expr = self.expression()?;
            Stmt::Expr(expr)
        };

        Ok(stmt)
    }

    fn expression(&mut self) -> Result<Expr<'p>, ParseError> {
        self.equality()
    }

    fn equality(&mut self) -> Result<Expr<'p>, ParseError> {
        let mut expr = self.comparison()?;

        while let TokenType::BangEqual | TokenType::EqualEqual = self.peek() {
            let Ok(op) = self.previous().kind.try_into() else {
                unreachable!()
            };

            let right = Box::new(self.comparison()?);
            expr = Expr::BinOp {
                left: Box::new(expr),
                right,
                op,
            }
        }

        Ok(expr)
    }

    fn comparison(&mut self) -> Result<Expr<'p>, ParseError> {
        let mut expr = self.term()?;

        while let TokenType::Greater
        | TokenType::GreaterEqual
        | TokenType::Less
        | TokenType::LessEqual = self.peek()
        {
            let Ok(op) = self.previous().kind.try_into() else {
                panic!("bad comparison?")
            };
            let right = Box::new(self.term()?);
            expr = Expr::BinOp {
                left: Box::new(expr),
                right,
                op,
            }
        }

        Ok(expr)
    }

    fn term(&mut self) -> Result<Expr<'p>, ParseError> {
        let mut expr = self.factor()?;

        while let TokenType::Minus | TokenType::Plus = self.peek() {
            let Ok(op) = self.advance().kind.try_into() else {
                panic!("bad term?")
            };
            let right = Box::new(self.factor()?);
            expr = Expr::BinOp {
                left: Box::new(expr),
                right,
                op,
            }
        }

        Ok(expr)
    }

    fn factor(&mut self) -> Result<Expr<'p>, ParseError> {
        let mut expr = self.unary()?;

        while let TokenType::Asterisk | TokenType::Slash = self.peek() {
            let Ok(op) = self.advance().kind.try_into() else {
                panic!("bad factor?")
            };
            let right = Box::new(self.unary()?);
            expr = Expr::BinOp {
                left: Box::new(expr),
                right,
                op,
            }
        }

        Ok(expr)
    }

    fn unary(&mut self) -> Result<Expr<'p>, ParseError> {
        if let TokenType::Bang | TokenType::Minus = self.peek() {
            let Ok(op) = self.advance().kind.try_into() else {
                panic!("bad unary")
            };
            let expr = Box::new(self.unary()?);
            Ok(Expr::UnOp { expr, op })
        } else {
            Ok(self.primary()?)
        }
    }

    fn primary(&mut self) -> Result<Expr<'p>, ParseError> {
        let expr = match self.peek() {
            TokenType::True => {
                self.advance();
                Expr::Literal(Value::Boolean(true))
            },
            TokenType::False => {
                self.advance();
                Expr::Literal(Value::Boolean(false))
            },
            TokenType::Empty => {
                self.advance();
                Expr::Literal(Value::Empty)
            },
            TokenType::Number => {
                let num = self.advance().lexeme.parse().unwrap();
                Expr::Literal(Value::Number(num))
            }
            TokenType::String => {
                let contents = Box::new(self.advance().lexeme.to_string());
                Expr::Literal(Value::String(contents))
            }
            TokenType::Identifier => Expr::Variable {
                name: self.advance().lexeme,
            },
            TokenType::LeftParen => {
                self.advance();
                let expr = Box::new(self.expression()?);
                self.consume(TokenType::RightParen)?;
                Expr::Grouping { expr }
            }

            // TokenType::Error => {
            //     let tk = self.advance();
            //     eprintln!("{}", ParseError::UnexpectedSymbol(tk.lexeme.to_string()));
            //     Expr::Literal(Value::Empty)
            // }

            _ => unreachable!(),
        };

        Ok(expr)
    }

    fn synchronize(&mut self) {
        self.advance();
        while self.peek() != TokenType::Eof {}
    }

    fn advance(&mut self) -> Token {
        if self.peek() != TokenType::Eof {
            self.current += 1;
        }

        self.tokens.pop().unwrap()
    }

    fn consume(&mut self, kind: TokenType) -> Result<Token, ParseError> {
        if self.peek() == kind {
            Ok(self.advance())
        } else {
            Err(ParseError::ExpectedToken(kind))
        }
    }

    fn check(&self, kind: TokenType) -> bool {
        if self.peek() == TokenType::Eof {
            false
        } else {
            self.peek() == kind
        }
    }

    fn peek(&self) -> TokenType {
        self.tokens.get(self.current).unwrap().kind
    }

    fn previous(&self) -> &Token {
        self.tokens.get(self.current - 1).unwrap()
    }
}
